import React from "react";
import { describe, it, expect, beforeEach, vi } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import GenerationPreview from "@/components/features/GenerationPreview";
import type { Highlight } from "@/components/features/TextHighlighter";

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation((query) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// Mock window.getSelection
let mockSelection: any;
let mockRange: any;

const createMockSelection = (text: string, startOffset: number, endOffset: number) => {
  mockRange = {
    getBoundingClientRect: vi.fn(() => ({
      left: 100,
      top: 200,
      width: 50,
      height: 20,
      right: 150,
      bottom: 220,
    })),
    toString: vi.fn(() => text),
    startOffset,
    endOffset,
    startContainer: { nodeType: 3, textContent: "Full text content" },
    endContainer: { nodeType: 3, textContent: "Full text content" },
  };

  mockSelection = {
    toString: vi.fn(() => text),
    rangeCount: text ? 1 : 0,
    getRangeAt: vi.fn(() => mockRange),
    removeAllRanges: vi.fn(),
  };

  window.getSelection = vi.fn(() => mockSelection);
};

describe("GenerationPreview Feedback Integration", () => {
  beforeEach(() => {
    createMockSelection("", 0, 0);
  });

  describe("Complete Feedback Flow", () => {
    it("should complete full flow: select text → add comment → select another text → add comment → submit feedback", async () => {
      const user = userEvent.setup();
      const onProvideFeedback = vi.fn();

      render(
        <GenerationPreview
          content="This is a test architecture proposal. The API design needs review."
          source="deep"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={onProvideFeedback}
        />
      );

      // First selection: "architecture proposal"
      createMockSelection("architecture proposal", 10, 31);
      fireEvent.mouseUp(document);

      await waitFor(() => {
        expect(screen.getByText("Add Comment")).toBeInTheDocument();
      });

      // Add first comment
      const textarea1 = screen.getByPlaceholderText("Enter your comment...");
      fireEvent.change(textarea1, { target: { value: "Consider using microservices" } });
      fireEvent.input(textarea1, { target: { value: "Consider using microservices" } });
      const saveButton1 = screen.getByText("Save");
      await waitFor(() => {
        expect(saveButton1).not.toBeDisabled();
      });
      await user.click(saveButton1);

      // Verify first highlight was created and popover closed
      await waitFor(() => {
        expect(screen.getByText(/1 comment/i)).toBeInTheDocument();
      });
      
      // Wait longer for the popover animation to complete
      await waitFor(() => {
        expect(screen.queryByText("Add Comment")).not.toBeInTheDocument();
      }, { timeout: 5000 });
      
      // Add extra delay to ensure popover is fully closed
      await new Promise(resolve => setTimeout(resolve, 200));

      // Second selection: "API design"
      createMockSelection("API design", 37, 47);
      fireEvent.mouseUp(document);

      await waitFor(() => {
        expect(screen.getByText("Add Comment")).toBeInTheDocument();
      });

      // Add second comment
      const textarea2 = screen.getByPlaceholderText("Enter your comment...");
      fireEvent.change(textarea2, { target: { value: "Add rate limiting" } });
      fireEvent.input(textarea2, { target: { value: "Add rate limiting" } });
      const saveButton2 = screen.getByText("Save");
      await waitFor(() => {
        expect(saveButton2).not.toBeDisabled();
      });
      await user.click(saveButton2);

      // Verify second highlight was created
      await waitFor(() => {
        expect(screen.getByText(/2 comments/i)).toBeInTheDocument();
      });

      // Add general feedback
      const feedbackInput = screen.getByPlaceholderText("Provide feedback...");
      await user.type(feedbackInput, "Overall looks good");

      // Submit all feedback
      const submitButton = screen.getByRole("button", { name: /submit feedback/i });
      await user.click(submitButton);

      // Verify XML structure
      await waitFor(() => {
        expect(onProvideFeedback).toHaveBeenCalledWith(
          expect.stringContaining("<highlight>architecture proposal</highlight>")
        );
        expect(onProvideFeedback).toHaveBeenCalledWith(
          expect.stringContaining("<comment>Consider using microservices</comment>")
        );
        expect(onProvideFeedback).toHaveBeenCalledWith(
          expect.stringContaining("<highlight>API design</highlight>")
        );
        expect(onProvideFeedback).toHaveBeenCalledWith(
          expect.stringContaining("<comment>Add rate limiting</comment>")
        );
        expect(onProvideFeedback).toHaveBeenCalledWith(
          expect.stringContaining("<general_feedback>Overall looks good</general_feedback>")
        );
      });

      // Verify highlights and feedback were cleared
      expect(screen.queryByText(/comments/i)).not.toBeInTheDocument();
      expect(feedbackInput).toHaveValue("");
    });

    it("should submit only highlights without general feedback", async () => {
      const user = userEvent.setup();
      const onProvideFeedback = vi.fn();

      render(
        <GenerationPreview
          content="Test content for highlighting"
          source="quick"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={onProvideFeedback}
        />
      );

      // Select and comment on text
      createMockSelection("Test content", 0, 12);
      fireEvent.mouseUp(document);

      await waitFor(() => {
        expect(screen.getByText("Add Comment")).toBeInTheDocument();
      });

      const textarea = screen.getByPlaceholderText("Enter your comment...");
      fireEvent.change(textarea, { target: { value: "This needs improvement" } });
      fireEvent.input(textarea, { target: { value: "This needs improvement" } });
      const saveButton = screen.getByText("Save");
      await waitFor(() => {
        expect(saveButton).not.toBeDisabled();
      });
      await user.click(saveButton);

      // Wait for highlight to be saved
      await waitFor(() => {
        expect(screen.getByText(/1 comment/i)).toBeInTheDocument();
      });

      // Submit without general feedback
      const submitButton = screen.getByRole("button", { name: /submit feedback/i });
      await user.click(submitButton);

      // Should contain only highlight-comment pair, no general_feedback tag
      await waitFor(() => {
        expect(onProvideFeedback).toHaveBeenCalledWith(
          "<highlight>Test content</highlight><comment>This needs improvement</comment>"
        );
      });
    });

    it("should submit only general feedback without highlights", async () => {
      const user = userEvent.setup();
      const onProvideFeedback = vi.fn();

      render(
        <GenerationPreview
          content="Test content"
          source="quick"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={onProvideFeedback}
        />
      );

      // Add only general feedback
      const feedbackInput = screen.getByPlaceholderText("Provide feedback...");
      await user.type(feedbackInput, "Looks good overall");

      const submitButton = screen.getByRole("button", { name: /submit feedback/i });
      await user.click(submitButton);

      // Should contain only general_feedback tag
      await waitFor(() => {
        expect(onProvideFeedback).toHaveBeenCalledWith(
          "<general_feedback>Looks good overall</general_feedback>"
        );
      });
    });
  });

  describe("Edge Cases", () => {
    it("should handle very long text selection (1000+ characters)", async () => {
      const user = userEvent.setup();
      const onProvideFeedback = vi.fn();
      const longText = "a".repeat(1000);

      render(
        <GenerationPreview
          content={`Introduction: ${longText} Conclusion`}
          source="deep"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={onProvideFeedback}
        />
      );

      // Select long text
      createMockSelection(longText, 14, 1014);
      fireEvent.mouseUp(document);

      await waitFor(() => {
        expect(screen.getByText("Add Comment")).toBeInTheDocument();
      });

      const textarea = screen.getByPlaceholderText("Enter your comment...");
      fireEvent.change(textarea, { target: { value: "This section is too long" } });
      fireEvent.input(textarea, { target: { value: "This section is too long" } });
      
      // Wait for Save button to be enabled
      const saveButton = screen.getByText("Save");
      await waitFor(() => {
        expect(saveButton).not.toBeDisabled();
      });
      await user.click(saveButton);

      // Wait for highlight to be saved
      await waitFor(() => {
        expect(screen.getByText(/1 comment/i)).toBeInTheDocument();
      });

      // Submit
      const submitButton = screen.getByRole("button", { name: /submit feedback/i });
      await user.click(submitButton);

      // Verify long text was properly encoded
      await waitFor(() => {
        const call = onProvideFeedback.mock.calls[0][0];
        expect(call).toContain("<highlight>");
        expect(call).toContain(longText);
        expect(call).toContain("</highlight>");
        expect(call).toContain("<comment>This section is too long</comment>");
      });
    });

    it("should handle markdown formatting within highlighted text", async () => {
      const user = userEvent.setup();
      const onProvideFeedback = vi.fn();

      render(
        <GenerationPreview
          content="Here is **bold text** and `code block` and [link](url)"
          source="deep"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={onProvideFeedback}
        />
      );

      // Select text with markdown (note: rendered text won't have markdown symbols)
      // The actual rendered text is "bold text and code block" not "**bold text** and `code block`"
      createMockSelection("bold text and code block", 8, 32);
      fireEvent.mouseUp(document);

      await waitFor(() => {
        expect(screen.getByText("Add Comment")).toBeInTheDocument();
      });

      const textarea = screen.getByPlaceholderText("Enter your comment...");
      fireEvent.change(textarea, { target: { value: "Review formatting" } });
      fireEvent.input(textarea, { target: { value: "Review formatting" } });
      const saveButton = screen.getByText("Save");
      await waitFor(() => {
        expect(saveButton).not.toBeDisabled();
      });
      await user.click(saveButton);

      // Wait for highlight to be saved
      await waitFor(() => {
        expect(screen.getByText(/1 comment/i)).toBeInTheDocument();
      });

      // Submit
      const submitButton = screen.getByRole("button", { name: /submit feedback/i });
      await user.click(submitButton);

      // Verify markdown was properly encoded
      await waitFor(() => {
        expect(onProvideFeedback).toHaveBeenCalledWith(
          expect.stringContaining("<highlight>**bold text** and `code block`</highlight>")
        );
      });
    });

    it("should escape special characters in both highlights and comments", async () => {
      const user = userEvent.setup();
      const onProvideFeedback = vi.fn();

      // Use backticks to escape the component tag in markdown
      render(
        <GenerationPreview
          content="Use `<Component>` & check props"
          source="deep"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={onProvideFeedback}
        />
      );

      // Select text - note the rendered text won't have backticks around the component
      createMockSelection("<Component> & check", 4, 23);
      fireEvent.mouseUp(document);

      await waitFor(() => {
        expect(screen.getByText("Add Comment")).toBeInTheDocument();
      });

      const textarea = screen.getByPlaceholderText("Enter your comment...");
      fireEvent.change(textarea, { target: { value: 'Use "props" & \'state\'' } });
      fireEvent.input(textarea, { target: { value: 'Use "props" & \'state\'' } });
      const saveButton = screen.getByText("Save");
      await waitFor(() => {
        expect(saveButton).not.toBeDisabled();
      });
      await user.click(saveButton);

      // Wait for highlight to be saved
      await waitFor(() => {
        expect(screen.getByText(/1 comment/i)).toBeInTheDocument();
      });

      // Submit
      const submitButton = screen.getByRole("button", { name: /submit feedback/i });
      await user.click(submitButton);

      // Verify special characters were escaped
      await waitFor(() => {
        expect(onProvideFeedback).toHaveBeenCalledWith(
          expect.stringContaining("&lt;Component&gt; &amp; check")
        );
        expect(onProvideFeedback).toHaveBeenCalledWith(
          expect.stringContaining("&quot;props&quot; &amp; &apos;state&apos;")
        );
      });
    });

    it("should handle empty selection gracefully", async () => {
      render(
        <GenerationPreview
          content="Test content"
          source="quick"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={vi.fn()}
        />
      );

      // Trigger mouseup with no selection
      createMockSelection("", 0, 0);
      fireEvent.mouseUp(document);

      // Should not show popover
      await waitFor(() => {
        expect(screen.queryByText("Add Comment")).not.toBeInTheDocument();
      });
    });

    it("should prevent overlapping highlights", async () => {
      const user = userEvent.setup();
      const onProvideFeedback = vi.fn();

      render(
        <GenerationPreview
          content="This is overlapping content here"
          source="deep"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={onProvideFeedback}
        />
      );

      // First selection
      createMockSelection("overlapping content", 8, 27);
      fireEvent.mouseUp(document);

      await waitFor(() => {
        expect(screen.getByText("Add Comment")).toBeInTheDocument();
      });

      const textarea1 = screen.getByPlaceholderText("Enter your comment...");
      fireEvent.change(textarea1, { target: { value: "First comment" } });
      fireEvent.input(textarea1, { target: { value: "First comment" } });
      const saveButton1 = screen.getByText("Save");
      await waitFor(() => {
        expect(saveButton1).not.toBeDisabled();
      });
      await user.click(saveButton1);

      // Wait for highlight to be saved and popover to close
      await waitFor(() => {
        expect(screen.getByText(/1 comment/i)).toBeInTheDocument();
      });
      
      await waitFor(() => {
        expect(screen.queryByText("Add Comment")).not.toBeInTheDocument();
      }, { timeout: 5000 });
      
      // Add extra delay to ensure popover is fully closed
      await new Promise(resolve => setTimeout(resolve, 200));

      // Try to select overlapping text
      createMockSelection("content here", 20, 32);
      fireEvent.mouseUp(document);

      // Should clear selection and not show popover
      await waitFor(() => {
        expect(mockSelection.removeAllRanges).toHaveBeenCalled();
      });
    });
  });

  describe("Highlight Badge Display", () => {
    it("should not show badge when no highlights exist", () => {
      render(
        <GenerationPreview
          content="Test content"
          source="quick"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={vi.fn()}
        />
      );

      expect(screen.queryByText(/comment/i)).not.toBeInTheDocument();
    });

    it("should show '1 comment' badge with single highlight", async () => {
      const user = userEvent.setup();

      render(
        <GenerationPreview
          content="Test content"
          source="quick"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={vi.fn()}
        />
      );

      // Add one highlight
      createMockSelection("Test", 0, 4);
      fireEvent.mouseUp(document);

      await waitFor(() => {
        expect(screen.getByText("Add Comment")).toBeInTheDocument();
      });

      const textarea = screen.getByPlaceholderText("Enter your comment...");
      fireEvent.change(textarea, { target: { value: "Comment text" } });
      fireEvent.input(textarea, { target: { value: "Comment text" } });
      
      // Wait for text to be fully typed
      await waitFor(() => {
        expect(textarea).toHaveValue("Comment text");
      });
      
      const saveButton = screen.getByText("Save");
      await waitFor(() => {
        expect(saveButton).not.toBeDisabled();
      });
      await user.click(saveButton);

      // Should show singular form
      await waitFor(() => {
        expect(screen.getByText("1 comment")).toBeInTheDocument();
      });
    });

    it("should show '2 comments' badge with multiple highlights", async () => {
      const user = userEvent.setup();

      render(
        <GenerationPreview
          content="First section and second section"
          source="quick"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={vi.fn()}
        />
      );

      // Add first highlight
      createMockSelection("First", 0, 5);
      fireEvent.mouseUp(document);

      await waitFor(() => {
        expect(screen.getByText("Add Comment")).toBeInTheDocument();
      });

      let textarea = screen.getByPlaceholderText("Enter your comment...");
      fireEvent.change(textarea, { target: { value: "First comment" } });
      fireEvent.input(textarea, { target: { value: "First comment" } });
      let saveButton = screen.getByText("Save");
      await waitFor(() => {
        expect(saveButton).not.toBeDisabled();
      });
      await user.click(saveButton);

      // Wait for first highlight to be saved and popover to close
      await waitFor(() => {
        expect(screen.getByText("1 comment")).toBeInTheDocument();
      });
      
      await waitFor(() => {
        expect(screen.queryByText("Add Comment")).not.toBeInTheDocument();
      }, { timeout: 5000 });
      
      // Add extra delay to ensure popover is fully closed
      await new Promise(resolve => setTimeout(resolve, 200));

      // Add second highlight
      createMockSelection("second", 18, 24);
      fireEvent.mouseUp(document);

      await waitFor(() => {
        expect(screen.getByText("Add Comment")).toBeInTheDocument();
      });

      textarea = screen.getByPlaceholderText("Enter your comment...");
      fireEvent.change(textarea, { target: { value: "Second comment" } });
      fireEvent.input(textarea, { target: { value: "Second comment" } });
      saveButton = screen.getByText("Save");
      await waitFor(() => {
        expect(saveButton).not.toBeDisabled();
      });
      await user.click(saveButton);

      // Should show plural form
      await waitFor(() => {
        expect(screen.getByText("2 comments")).toBeInTheDocument();
      });
    });

    it("should hide badge after feedback submission", async () => {
      const user = userEvent.setup();

      render(
        <GenerationPreview
          content="Test content"
          source="quick"
          onAccept={vi.fn()}
          onReject={vi.fn()}
          onProvideFeedback={vi.fn()}
        />
      );

      // Add highlight
      createMockSelection("Test", 0, 4);
      fireEvent.mouseUp(document);

      await waitFor(() => {
        expect(screen.getByText("Add Comment")).toBeInTheDocument();
      });

      const textarea = screen.getByPlaceholderText("Enter your comment...");
      fireEvent.change(textarea, { target: { value: "Comment" } });
      fireEvent.input(textarea, { target: { value: "Comment" } });
      const saveButton = screen.getByText("Save");
      await waitFor(() => {
        expect(saveButton).not.toBeDisabled();
      });
      await user.click(saveButton);

      await waitFor(() => {
        expect(screen.getByText("1 comment")).toBeInTheDocument();
      });

      // Submit feedback
      const submitButton = screen.getByRole("button", { name: /submit feedback/i });
      await user.click(submitButton);

      // Badge should be hidden
      await waitFor(() => {
        expect(screen.queryByText(/comment/i)).not.toBeInTheDocument();
      });
    });
  });
});
